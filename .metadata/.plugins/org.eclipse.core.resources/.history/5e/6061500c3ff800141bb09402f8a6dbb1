package com.codey.OpenGL;

import java.io.FileNotFoundException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Random;

import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;
import static org.apache.commons.math3.util.FastMath.toDegrees;

public class SimulationCreator {

	private static final double SOLAR_SYSTEM_WIDTH = 1920;
	private static final double SOLAR_SYSTEM_HEIGHT = 1080;

	private static final Vector3D MILKYWAY_POSITION = new Vector3D(0, 0, 0);
	private static final Vector3D MILKYWAY_VELOCITY = new Vector3D(0, 0, 0);
	private static final double MILKYWAY_MASS = 100;
	private static final double MILKYWAY_RADIUS = 5;
	private static final double MILKYWAY_DISK_RADIUS = 50;
	private static final double[] BLACKHOLE_COLOR = {.1,.1,.1};

	private static final Vector3D ANDROMEDA_POSITION = new Vector3D(-75, 55, 0);
	private static final Vector3D ANDROMEDA_VELOCITY = new Vector3D(37, 0, 0);
	private static final double ANDROMEDA_MASS = 100;
	private static final double ANDROMEDA_RADIUS = 5;
	private static final double ANDROMEDA_DISK_RADIUS = 50;
	
	
	private static final boolean SHOW_OCTTREE = false;
	private static final double GRAVITATIONAL_CONSTANT = 449.93;
	private static final int NUM_STARS = 100;
	private static final double TIME_STEP = .01;
	private static final double CONSERVATION_TOLERANCE = 1;
	private static final double BARNS_HUT_THETA = .5;
	private static final int MAX_STEPS = 2000;
	
	private double gravitationalConstant;
	private double conservationTolerance;
	private double barnesHutTheta;
	private double collisionThreshold;
	private double timeStep;
	
	private int maxStep;
	private int particleToTrack;
	private int recurringSave;
	
	private boolean showOctTree;
	private boolean breakOnEnergyNotConserved;
	private boolean graphicsEnabled;

	private String conservationFileName;
	private String simulationFileName;
	private String performanceFileName;
	private boolean zipFiles;

	private Librarian linda;
	
	public ArrayList<Particle> particles;
	public SSGravitationalForce gravity;
	private static int step = 0;
	
	public SimulationCreator() throws FileNotFoundException, UnsupportedEncodingException {
		
		particles = new ArrayList<Particle>();

		milkyWay();
		andromeda();
		
		linda = new Librarian(particles, null);
	}
	
	private void milkyWay() {
		Particle blackHole;
		Particle star;
		Vector3D position;
		Vector3D velocity;
		double radius;
		Random random = new Random();
		
		blackHole = new Particle(MILKYWAY_POSITION, MILKYWAY_VELOCITY, MILKYWAY_MASS, MILKYWAY_RADIUS);
		particles.add(blackHole);
		System.out.print(blackHole);
		
		for (int i = 0; i < NUM_STARS; i++) {
			radius = (random.nextDouble() * MILKYWAY_DISK_RADIUS);
			position = randomPointOnCircle(radius);
			velocity = velocityVector(position, Math.sqrt(GRAVITATIONAL_CONSTANT * MILKYWAY_MASS / radius));
			
			position = position.add(MILKYWAY_POSITION);
			velocity = velocity.add(MILKYWAY_VELOCITY);
			
			star = new Particle(position, velocity, 1, 1);
			particles.add(star);
			System.out.print(star);
		}
	}
	
	private void andromeda() {
		Particle blackHole;
		Particle star;
		Vector3D position;
		Vector3D velocity;
		double radius;
		Random random = new Random();
		
		blackHole = new Particle(ANDROMEDA_POSITION, ANDROMEDA_VELOCITY, ANDROMEDA_MASS, ANDROMEDA_RADIUS);
		particles.add(blackHole);
		System.out.print(blackHole);

		for (int i = 0; i < NUM_STARS; i++) {
			radius = (random.nextDouble() * ANDROMEDA_DISK_RADIUS);
			position = randomPointOnCircle(radius);
			velocity = velocityVector(position, Math.sqrt(GRAVITATIONAL_CONSTANT * ANDROMEDA_MASS / radius));
			
			position = position.add(ANDROMEDA_POSITION);
			velocity = velocity.add(ANDROMEDA_VELOCITY);
			
			star = new Particle(position, velocity, 1, 1);
			particles.add(star);
			System.out.print(star);
		}
	}
	
	private Vector3D randomPointOnCircle(double radius) {
		Random randomGenerator;
		double theta, x, y, z;
		
		randomGenerator = new Random();
		
		theta = 2 * Math.PI * randomGenerator.nextDouble();
		x = radius * Math.cos(theta);
		y = radius * Math.sin(theta);
		z = y * Math.cos(Math.PI / 4);
		
		return new Vector3D(x, y, z);
	}
	
	private Vector3D velocityVector(Vector3D position, double velocity) {
		Vector3D v;
		double theta;
		
		theta = Math.atan2(position.getY(), position.getX()) + (Math.PI / 2.0);
		
		
		v = new Vector3D(Math.cos(theta), Math.sin(theta), 0);
		
		return v.scalarMultiply(velocity);
	}

	/*----------------------------------------------------------------------
	 *  File Writing Methods
	 */---------------------------------------------------------------------
	 
	private String optionsString() {
		String options = "";

		options += String.format("Gravitational_Constant:  %.16f\n", gravitationalConstant);
		options += String.format("Conservation_Tolerance:  %.16f\n", conservationTolerance);
		options += String.format("Collision_Threshold:     %.16f\n", collisionThreshold);
		options += String.format("Barnes_Hut_Theta:        %.16f\n", barnesHutTheta);
		options += String.format("Time_Step:               %.16f\n", timeStep);
		options += String.format("Max_Step:                %d\n", maxStep);
		options += String.format("Particle_To_Track:       %d\n", particleToTrack);
		options += String.format("Recurring_Save:          %d\n", recurringSave);
		options += "Show_Oct_Tree:           " + showOctTree + "\n";
		options += "Strict_Conservation:     " + breakOnEnergyNotConserved + "\n";
		options += "Graphics_Enabled:        " + graphicsEnabled + "\n";
		options += "\n";
		options += "Conservation_File_Path:  " + conservationFileName + "\n";
		options += "Performance_File_Path:   " + performanceFileName + "\n";
		options += "Simulation_File_Path:    " + simulationFileName + "\n";
		options += "\n";
		
		return options;
	}
}
